<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Code Access</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        .code-block {
            border: 1px solid #ccc;
            margin-bottom: 25px; /* Increased margin for heading */
            padding: 10px;
            position: relative;
        }
        .code-heading {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .code-area {
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            font-family: monospace;
            display: block;
            width: 95%; /* Adjust as needed */
            min-height: 80px; /* Adjust as needed */
            border: none;
            padding: 5px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .copy-button {
            position: absolute;
            top: 30px; /* Adjusted top position to accommodate heading */
            right: 5px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .copy-button:hover {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>

    <h1>Quick Code Reference</h1>

    <div class="code-block">
        <div class="code-heading">Snippet 1 Title</div>
        <textarea class="code-area" id="code1" readonly>
●	Fields: name, age

●	Constructor to initialize the fields

●	Abstract method:
●	Create a class Student that inherits from Person:

○	Additional fields: rollNumber, course

○	Override the displayDetails() method to print all student details

●	Create another class Teacher that also extends Person:

○	Additional fields: employeeId, subject

○	Override the displayDetails() method to print all teacher details

●	Demonstrate encapsulation by making all fields private and using getter and setter methods.

●	In the main() method:

○	Create an array of Person references (use polymorphism).

○	Store both Student and Teacher objects.

○	Call the displayDetails() method for each object using a loop.

        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code1')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">producer consumer semaphore</div>
        <textarea class="code-area" id="code2" readonly>
            #include <stdio.h>
                #include <pthread.h>
                #include <semaphore.h>
                #include <unistd.h>
                
                #define SIZE 5
                
                int buffer[SIZE];
                int in = 0, out = 0;
                
                sem_t empty, full, mutex;
                
                void* producer(void* arg) {
                    int item;
                    for (int i = 0; i < 10; i++) {
                        item = i + 1;
                        sem_wait(&empty);
                        sem_wait(&mutex);
                
                        buffer[in] = item;
                        printf("Producer produced: %d\n", item);
                        in = (in + 1) % SIZE;
                
                        sem_post(&mutex);
                        sem_post(&full);
                        sleep(1);
                    }
                    return NULL;
                }
                
                void* consumer(void* arg) {
                    int item;
                    for (int i = 0; i < 10; i++) {
                        sem_wait(&full);
                        sem_wait(&mutex);
                
                        item = buffer[out];
                        printf("Consumer consumed: %d\n", item);
                        out = (out + 1) % SIZE;
                
                        sem_post(&mutex);
                        sem_post(&empty);
                        sleep(2);
                    }
                    return NULL;
                }
                
                int main() {
                    pthread_t prod, cons;
                
                    sem_init(&empty, 0, SIZE);
                    sem_init(&full, 0, 0);
                    sem_init(&mutex, 0, 1);
                
                    pthread_create(&prod, NULL, producer, NULL);
                    pthread_create(&cons, NULL, consumer, NULL);
                
                    pthread_join(prod, NULL);
                    pthread_join(cons, NULL);
                
                    sem_destroy(&empty);
                    sem_destroy(&full);
                    sem_destroy(&mutex);
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code2')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">producer consumer mutex</div>
        <textarea class="code-area" id="code3" readonly>
            #include <stdio.h>
                #include <pthread.h>
                #include <unistd.h>
                
                #define SIZE 5
                
                int buffer[SIZE];
                int count = 0;
                int in = 0, out = 0;
                
                pthread_mutex_t mutex;
                
                void* producer(void* arg) {
                    int item;
                    for (int i = 0; i < 10; i++) {
                        item = i + 1;
                
                        pthread_mutex_lock(&mutex);
                        if (count < SIZE) {
                            buffer[in] = item;
                            printf("Producer produced: %d\n", item);
                            in = (in + 1) % SIZE;
                            count++;
                        } else {
                            printf("Buffer full. Producer waiting...\n");
                        }
                        pthread_mutex_unlock(&mutex);
                
                        sleep(1);
                    }
                    return NULL;
                }
                
                void* consumer(void* arg) {
                    int item;
                    for (int i = 0; i < 10; i++) {
                        pthread_mutex_lock(&mutex);
                        if (count > 0) {
                            item = buffer[out];
                            printf("Consumer consumed: %d\n", item);
                            out = (out + 1) % SIZE;
                            count--;
                        } else {
                            printf("Buffer empty. Consumer waiting...\n");
                        }
                        pthread_mutex_unlock(&mutex);
                
                        sleep(2);
                    }
                    return NULL;
                }
                
                int main() {
                    pthread_t prod, cons;
                    pthread_mutex_init(&mutex, NULL);
                
                    pthread_create(&prod, NULL, producer, NULL);
                    pthread_create(&cons, NULL, consumer, NULL);
                
                    pthread_join(prod, NULL);
                    pthread_join(cons, NULL);
                
                    pthread_mutex_destroy(&mutex);
                
                    return 0;
                }
                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code3')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">reader writer semaphore</div>
        <textarea class="code-area" id="code4" readonly>
            #include <stdio.h>
                #include <pthread.h>
                #include <semaphore.h>
                #include <unistd.h>
                
                int readcount = 0;  // number of active readers
                sem_t mutex;        // controls access to readcount
                sem_t wrt;          // ensures writers' exclusive access
                
                void* reader(void* arg) {
                    int id = *(int*)arg;
                    while (1) {
                        sem_wait(&mutex);
                        readcount++;
                        if (readcount == 1)
                            sem_wait(&wrt); // first reader locks the writer
                        sem_post(&mutex);
                
                        printf("Reader %d is reading\n", id);
                        sleep(1); // simulate reading
                
                        sem_wait(&mutex);
                        readcount--;
                        if (readcount == 0)
                            sem_post(&wrt); // last reader unlocks the writer
                        sem_post(&mutex);
                
                        sleep(1); // simulate delay before next read
                    }
                    return NULL;
                }
                
                void* writer(void* arg) {
                    int id = *(int*)arg;
                    while (1) {
                        sem_wait(&wrt);
                        printf("Writer %d is writing\n", id);
                        sleep(2); // simulate writing
                        sem_post(&wrt);
                        sleep(2); // simulate delay before next write
                    }
                    return NULL;
                }
                
                int main() {
                    pthread_t r[3], w[2];
                    int r_id[3] = {1, 2, 3};
                    int w_id[2] = {1, 2};
                
                    sem_init(&mutex, 0, 1);
                    sem_init(&wrt, 0, 1);
                
                    for (int i = 0; i < 3; i++)
                        pthread_create(&r[i], NULL, reader, &r_id[i]);
                    for (int i = 0; i < 2; i++)
                        pthread_create(&w[i], NULL, writer, &w_id[i]);
                
                    for (int i = 0; i < 3; i++)
                        pthread_join(r[i], NULL);
                    for (int i = 0; i < 2; i++)
                        pthread_join(w[i], NULL);
                
                    sem_destroy(&mutex);
                    sem_destroy(&wrt);
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code4')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">reader writer mutex</div>
        <textarea class="code-area" id="code5" readonly>
            #include <stdio.h>
                #include <pthread.h>
                #include <unistd.h>
                
                int readcount = 0;
                pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;      // controls readcount
                pthread_mutex_t write_lock = PTHREAD_MUTEX_INITIALIZER; // ensures writer exclusivity
                
                void* reader(void* arg) {
                    int id = *(int*)arg;
                    while (1) {
                        pthread_mutex_lock(&mutex);
                        readcount++;
                        if (readcount == 1)
                            pthread_mutex_lock(&write_lock); // first reader blocks writers
                        pthread_mutex_unlock(&mutex);
                
                        printf("Reader %d is reading\n", id);
                        sleep(1);
                
                        pthread_mutex_lock(&mutex);
                        readcount--;
                        if (readcount == 0)
                            pthread_mutex_unlock(&write_lock); // last reader unlocks writer
                        pthread_mutex_unlock(&mutex);
                
                        sleep(1);
                    }
                    return NULL;
                }
                
                void* writer(void* arg) {
                    int id = *(int*)arg;
                    while (1) {
                        pthread_mutex_lock(&write_lock);
                        printf("Writer %d is writing\n", id);
                        sleep(2);
                        pthread_mutex_unlock(&write_lock);
                
                        sleep(2);
                    }
                    return NULL;
                }
                
                int main() {
                    pthread_t r[3], w[2];
                    int r_id[3] = {1, 2, 3};
                    int w_id[2] = {1, 2};
                
                    for (int i = 0; i < 3; i++)
                        pthread_create(&r[i], NULL, reader, &r_id[i]);
                    for (int i = 0; i < 2; i++)
                        pthread_create(&w[i], NULL, writer, &w_id[i]);
                
                    for (int i = 0; i < 3; i++)
                        pthread_join(r[i], NULL);
                    for (int i = 0; i < 2; i++)
                        pthread_join(w[i], NULL);
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code5')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">dining philospher semaphore</div>
        <textarea class="code-area" id="code6" readonly>
            #include <stdio.h>
                #include <pthread.h>
                #include <semaphore.h>
                #include <unistd.h>
                
                #define N 5  // Number of philosophers
                
                sem_t mutex;  // For mutual exclusion of shared resource (forks)
                sem_t forks[N]; // Semaphores representing forks
                
                void* philosopher(void* num) {
                    int id = *(int*)num;
                    while (1) {
                        printf("Philosopher %d is thinking\n", id);
                        sleep(1); // simulate thinking
                
                        sem_wait(&mutex); // Ensure mutual exclusion for fork usage
                        sem_wait(&forks[id]);  // Take left fork
                        sem_wait(&forks[(id + 1) % N]); // Take right fork
                
                        printf("Philosopher %d is eating\n", id);
                        sleep(2); // simulate eating
                
                        sem_post(&forks[id]);  // Release left fork
                        sem_post(&forks[(id + 1) % N]); // Release right fork
                        sem_post(&mutex); // Release mutual exclusion for the next philosopher
                
                        sleep(1); // simulate delay before thinking again
                    }
                    return NULL;
                }
                
                int main() {
                    pthread_t philosophers[N];
                    int philosopher_ids[N] = {0, 1, 2, 3, 4};
                
                    // Initialize the mutex and the forks (semaphores)
                    sem_init(&mutex, 0, 1); // mutex for mutual exclusion
                    for (int i = 0; i < N; i++) {
                        sem_init(&forks[i], 0, 1); // each fork is initially available
                    }
                
                    // Create philosopher threads
                    for (int i = 0; i < N; i++) {
                        pthread_create(&philosophers[i], NULL, philosopher, &philosopher_ids[i]);
                    }
                
                    // Join philosopher threads
                    for (int i = 0; i < N; i++) {
                        pthread_join(philosophers[i], NULL);
                    }
                
                    // Clean up semaphores
                    for (int i = 0; i < N; i++) {
                        sem_destroy(&forks[i]);
                    }
                    sem_destroy(&mutex);
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code6')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">dining philospher mutex </div>
        <textarea class="code-area" id="code7" readonly>
            #include <stdio.h>
                #include <pthread.h>
                #include <unistd.h>
                
                #define N 5  // Number of philosophers
                
                pthread_mutex_t forks[N]; // Mutexes representing forks
                
                void* philosopher(void* num) {
                    int id = *(int*)num;
                    while (1) {
                        printf("Philosopher %d is thinking\n", id);
                        sleep(1); // simulate thinking
                
                        pthread_mutex_lock(&forks[id]); // Take left fork
                        pthread_mutex_lock(&forks[(id + 1) % N]); // Take right fork
                
                        printf("Philosopher %d is eating\n", id);
                        sleep(2); // simulate eating
                
                        pthread_mutex_unlock(&forks[id]); // Release left fork
                        pthread_mutex_unlock(&forks[(id + 1) % N]); // Release right fork
                
                        sleep(1); // simulate delay before thinking again
                    }
                    return NULL;
                }
                
                int main() {
                    pthread_t philosophers[N];
                    int philosopher_ids[N] = {0, 1, 2, 3, 4};
                
                    // Initialize the mutexes for each fork
                    for (int i = 0; i < N; i++) {
                        pthread_mutex_init(&forks[i], NULL);
                    }
                
                    // Create philosopher threads
                    for (int i = 0; i < N; i++) {
                        pthread_create(&philosophers[i], NULL, philosopher, &philosopher_ids[i]);
                    }
                
                    // Join philosopher threads
                    for (int i = 0; i < N; i++) {
                        pthread_join(philosophers[i], NULL);
                    }
                
                    // Clean up mutexes
                    for (int i = 0; i < N; i++) {
                        pthread_mutex_destroy(&forks[i]);
                    }
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code7')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">disk scheduling</div>
        <textarea class="code-area" id="code8" readonly>
            #include <stdio.h>
                #include <stdlib.h>
                #define MAX 100
                
                // Absolute difference
                int absDiff(int a, int b) {
                    return a > b ? a - b : b - a;
                }
                
                // FCFS
                int fcfs(int req[], int n, int head) {
                    int total = 0;
                    printf("FCFS Steps:\n");
                    for (int i = 0; i < n; i++) {
                        printf("Move from %d to %d, Head movement: %d\n", head, req[i], absDiff(head, req[i]));
                        total += absDiff(head, req[i]);
                        head = req[i];
                    }
                    printf("Total Tracks Moved (FCFS): %d\n", total);
                    printf("Average Seek Time (FCFS): %.2f\n", (float)total / n);
                    return total;
                }
                
                // SSTF
                int sstf(int req[], int n, int head) {
                    int total = 0, done[MAX] = {0}, count = 0;
                    printf("SSTF Steps:\n");
                
                    while (count < n) {
                        int min = 1e9, index = -1;
                        for (int i = 0; i < n; i++) {
                            if (!done[i] && absDiff(head, req[i]) < min) {
                                min = absDiff(head, req[i]);
                                index = i;
                            }
                        }
                        printf("Move from %d to %d, Head movement: %d\n", head, req[index], min);
                        total += min;
                        head = req[index];
                        done[index] = 1;
                        count++;
                    }
                    printf("Total Tracks Moved (SSTF): %d\n", total);
                    printf("Average Seek Time (SSTF): %.2f\n", (float)total / n);
                    return total;
                }
                
                // SCAN
                int scan(int req[], int n, int head, int size) {
                    int total = 0, temp[MAX], i, index;
                    printf("SCAN Steps:\n");
                
                    for (i = 0; i < n; i++) temp[i] = req[i];
                    temp[n++] = head;
                
                    // Sort
                    for (i = 0; i < n - 1; i++)
                        for (int j = 0; j < n - i - 1; j++)
                            if (temp[j] > temp[j + 1]) {
                                int t = temp[j]; temp[j] = temp[j + 1]; temp[j + 1] = t;
                            }
                
                    for (i = 0; i < n; i++) if (temp[i] == head) { index = i; break; }
                
                    for (i = index; i > 0; i--) {
                        printf("Move from %d to %d, Head movement: %d\n", temp[i], temp[i - 1], absDiff(temp[i], temp[i - 1]));
                        total += absDiff(temp[i], temp[i - 1]);
                    }
                    printf("Move from %d to 0, Head movement: %d\n", temp[0], absDiff(temp[0], 0));
                    total += absDiff(temp[0], 0);
                    for (i = index + 1; i < n; i++) {
                        printf("Move from %d to %d, Head movement: %d\n", temp[i], temp[i - 1], absDiff(temp[i], temp[i - 1]));
                        total += absDiff(temp[i], temp[i - 1]);
                    }
                
                    printf("Total Tracks Moved (SCAN): %d\n", total);
                    printf("Average Seek Time (SCAN): %.2f\n", (float)total / n);
                    return total;
                }
                
                // C-SCAN
                int cscan(int req[], int n, int head, int size) {
                    int total = 0, temp[MAX], i, index;
                    printf("C-SCAN Steps:\n");
                
                    for (i = 0; i < n; i++) temp[i] = req[i];
                    temp[n++] = head;
                
                    // Sort
                    for (i = 0; i < n - 1; i++)
                        for (int j = 0; j < n - i - 1; j++)
                            if (temp[j] > temp[j + 1]) {
                                int t = temp[j]; temp[j] = temp[j + 1]; temp[j + 1] = t;
                            }
                
                    for (i = 0; i < n; i++) if (temp[i] == head) { index = i; break; }
                
                    for (i = index; i < n - 1; i++) {
                        printf("Move from %d to %d, Head movement: %d\n", temp[i], temp[i + 1], absDiff(temp[i], temp[i + 1]));
                        total += absDiff(temp[i], temp[i + 1]);
                    }
                    printf("Move from %d to %d, Head movement: %d\n", temp[n - 1], size - 1, absDiff(temp[n - 1], size - 1));
                    total += absDiff(temp[n - 1], size - 1);
                    printf("Move from %d to 0, Head movement: %d\n", size - 1, absDiff(size - 1, 0));
                    total += absDiff(size - 1, 0);
                    for (i = 0; i < index; i++) {
                        printf("Move from %d to %d, Head movement: %d\n", temp[i], temp[i + 1], absDiff(temp[i], temp[i + 1]));
                        total += absDiff(temp[i], temp[i + 1]);
                    }
                
                    printf("Total Tracks Moved (C-SCAN): %d\n", total);
                    printf("Average Seek Time (C-SCAN): %.2f\n", (float)total / n);
                    return total;
                }
                
                // Main function
                int main() {
                    int n, head, size, req[MAX];
                
                    printf("Enter number of disk requests: ");
                    scanf("%d", &n);
                    printf("Enter disk requests: ");
                    for (int i = 0; i < n; i++) scanf("%d", &req[i]);
                
                    printf("Enter initial head position: ");
                    scanf("%d", &head);
                    printf("Enter total disk size: ");
                    scanf("%d", &size);
                
                    printf("\nTotal Head Movements:\n");
                    fcfs(req, n, head);
                    sstf(req, n, head);
                    scan(req, n, head, size);
                    cscan(req, n, head, size);
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code8')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">page replacement algorithms</div>
        <textarea class="code-area" id="code9" readonly>
            #include <stdio.h>
                #include <limits.h>
                
                #define MAX 100
                
                int isPageInFrame(int frames[], int frameCount, int page) {
                    for (int i = 0; i < frameCount; i++) {
                        if (frames[i] == page)
                            return 1;
                    }
                    return 0;
                }
                
                void printFrames(int frames[], int frameCount) {
                    printf("Frames: ");
                    for (int i = 0; i < frameCount; i++) {
                        if (frames[i] == -1)
                            printf(" - ");
                        else
                            printf(" %d ", frames[i]);
                    }
                    printf("\n");
                }
                
                // FIFO Algorithm
                void fifo(int pages[], int n, int frameCount) {
                    int frames[MAX], front = 0;
                    int pageFaults = 0, pageHits = 0;
                
                    for (int i = 0; i < frameCount; i++) frames[i] = -1;
                
                    printf("\n--- FIFO Algorithm ---\n");
                    for (int i = 0; i < n; i++) {
                        printf("Page %d -> ", pages[i]);
                        if (isPageInFrame(frames, frameCount, pages[i])) {
                            pageHits++;
                            printf("Hit | ");
                        } else {
                            frames[front] = pages[i];
                            front = (front + 1) % frameCount;
                            pageFaults++;
                            printf("Fault | ");
                        }
                        printFrames(frames, frameCount);
                    }
                
                    printf("Total Page Hits: %d\nTotal Page Faults: %d\n\n", pageHits, pageFaults);
                }
                
                // Optimal Algorithm
                void optimal(int pages[], int n, int frameCount) {
                    int frames[MAX];
                    int pageFaults = 0, pageHits = 0;
                
                    for (int i = 0; i < frameCount; i++) frames[i] = -1;
                
                    printf("--- Optimal Algorithm ---\n");
                    for (int i = 0; i < n; i++) {
                        int currentPage = pages[i];
                        int indexToReplace = -1;
                
                        printf("Page %d -> ", currentPage);
                        if (isPageInFrame(frames, frameCount, currentPage)) {
                            pageHits++;
                            printf("Hit | ");
                        } else {
                            for (int j = 0; j < frameCount; j++) {
                                if (frames[j] == -1) {
                                    indexToReplace = j;
                                    break;
                                }
                            }
                
                            if (indexToReplace == -1) {
                                int farthest = -1;
                                for (int j = 0; j < frameCount; j++) {
                                    int k;
                                    for (k = i + 1; k < n; k++) {
                                        if (frames[j] == pages[k]) break;
                                    }
                                    if (k == n) { // Never used again
                                        indexToReplace = j;
                                        break;
                                    }
                                    if (k > farthest) {
                                        farthest = k;
                                        indexToReplace = j;
                                    }
                                }
                            }
                
                            frames[indexToReplace] = currentPage;
                            pageFaults++;
                            printf("Fault | ");
                        }
                        printFrames(frames, frameCount);
                    }
                
                    printf("Total Page Hits: %d\nTotal Page Faults: %d\n\n", pageHits, pageFaults);
                }
                
                // LRU Algorithm
                void lru(int pages[], int n, int frameCount) {
                    int frames[MAX], lastUsed[MAX];
                    int pageFaults = 0, pageHits = 0;
                    int time = 0;
                
                    for (int i = 0; i < frameCount; i++) {
                        frames[i] = -1;
                        lastUsed[i] = -1;
                    }
                
                    printf("--- LRU Algorithm ---\n");
                    for (int i = 0; i < n; i++) {
                        time++;
                        int currentPage = pages[i];
                        int indexToReplace = -1;
                
                        printf("Page %d -> ", currentPage);
                        int found = 0;
                        for (int j = 0; j < frameCount; j++) {
                            if (frames[j] == currentPage) {
                                pageHits++;
                                lastUsed[j] = time;
                                found = 1;
                                printf("Hit | ");
                                break;
                            }
                        }
                
                        if (!found) {
                            for (int j = 0; j < frameCount; j++) {
                                if (frames[j] == -1) {
                                    indexToReplace = j;
                                    break;
                                }
                            }
                
                            if (indexToReplace == -1) {
                                int lruTime = INT_MAX;
                                for (int j = 0; j < frameCount; j++) {
                                    if (lastUsed[j] < lruTime) {
                                        lruTime = lastUsed[j];
                                        indexToReplace = j;
                                    }
                                }
                            }
                
                            frames[indexToReplace] = currentPage;
                            lastUsed[indexToReplace] = time;
                            pageFaults++;
                            printf("Fault | ");
                        }
                        printFrames(frames, frameCount);
                    }
                
                    printf("Total Page Hits: %d\nTotal Page Faults: %d\n\n", pageHits, pageFaults);
                }
                
                // Main
                int main() {
                    int pages[MAX], n, frameCount;
                
                    printf("Enter number of pages: ");
                    scanf("%d", &n);
                
                    printf("Enter page reference string: ");
                    for (int i = 0; i < n; i++) scanf("%d", &pages[i]);
                
                    printf("Enter number of frames: ");
                    scanf("%d", &frameCount);
                
                    fifo(pages, n, frameCount);
                    optimal(pages, n, frameCount);
                    lru(pages, n, frameCount);
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code9')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">placement strategies</div>
        <textarea class="code-area" id="code10" readonly>
            #include <stdio.h>

                #define MAX 100
                
                // Function to reset allocation array
                void resetAlloc(int allocation[], int n) {
                    for (int i = 0; i < n; i++)
                        allocation[i] = -1;
                }
                
                // External Fragmentation Calculation
                void calculateExternalFragmentation(int blockSize[], int blocks, int allocation[], int processes) {
                    int externalFragmentation = 0;
                    int unallocated = 0;
                
                    // Check if there is any unallocated process
                    for (int i = 0; i < processes; i++) {
                        if (allocation[i] == -1) {
                            unallocated = 1;
                            break;
                        }
                    }
                
                    // If there is any unallocated process, sum up all the remaining block sizes
                    if (unallocated) {
                        for (int i = 0; i < blocks; i++) {
                            externalFragmentation += blockSize[i];
                        }
                        printf("Total External Fragmentation: %d\n", externalFragmentation);
                    } else {
                        printf("No External Fragmentation (all processes allocated).\n");
                    }
                }
                
                // First Fit Strategy
                void firstFit(int blockSize[], int blocks, int processSize[], int processes) {
                    int allocation[MAX];
                    resetAlloc(allocation, processes);
                
                    for (int i = 0; i < processes; i++) {
                        for (int j = 0; j < blocks; j++) {
                            if (blockSize[j] >= processSize[i]) {
                                allocation[i] = j;
                                blockSize[j] -= processSize[i];
                                break;
                            }
                        }
                    }
                
                    printf("\nFirst Fit Allocation:\n");
                    for (int i = 0; i < processes; i++) {
                        printf("Process %d -> ", i + 1);
                        if (allocation[i] != -1)
                            printf("Block %d\n", allocation[i] + 1);
                        else
                            printf("Not Allocated\n");
                    }
                
                    calculateExternalFragmentation(blockSize, blocks, allocation, processes);
                }
                
                // Next Fit Strategy
                void nextFit(int blockSize[], int blocks, int processSize[], int processes) {
                    int allocation[MAX];
                    resetAlloc(allocation, processes);
                    int lastPos = 0;
                
                    for (int i = 0; i < processes; i++) {
                        int j = lastPos;
                        int count = 0;
                
                        while (count < blocks) {
                            if (blockSize[j] >= processSize[i]) {
                                allocation[i] = j;
                                blockSize[j] -= processSize[i];
                                lastPos = j;
                                break;
                            }
                            j = (j + 1) % blocks;
                            count++;
                        }
                    }
                
                    printf("\nNext Fit Allocation:\n");
                    for (int i = 0; i < processes; i++) {
                        printf("Process %d -> ", i + 1);
                        if (allocation[i] != -1)
                            printf("Block %d\n", allocation[i] + 1);
                        else
                            printf("Not Allocated\n");
                    }
                
                    calculateExternalFragmentation(blockSize, blocks, allocation, processes);
                }
                
                // Best Fit Strategy
                void bestFit(int blockSize[], int blocks, int processSize[], int processes) {
                    int allocation[MAX];
                    resetAlloc(allocation, processes);
                
                    for (int i = 0; i < processes; i++) {
                        int bestIdx = -1;
                        for (int j = 0; j < blocks; j++) {
                            if (blockSize[j] >= processSize[i]) {
                                if (bestIdx == -1 || blockSize[j] < blockSize[bestIdx])
                                    bestIdx = j;
                            }
                        }
                        if (bestIdx != -1) {
                            allocation[i] = bestIdx;
                            blockSize[bestIdx] -= processSize[i];
                        }
                    }
                
                    printf("\nBest Fit Allocation:\n");
                    for (int i = 0; i < processes; i++) {
                        printf("Process %d -> ", i + 1);
                        if (allocation[i] != -1)
                            printf("Block %d\n", allocation[i] + 1);
                        else
                            printf("Not Allocated\n");
                    }
                
                    calculateExternalFragmentation(blockSize, blocks, allocation, processes);
                }
                
                // Worst Fit Strategy
                void worstFit(int blockSize[], int blocks, int processSize[], int processes) {
                    int allocation[MAX];
                    resetAlloc(allocation, processes);
                
                    for (int i = 0; i < processes; i++) {
                        int worstIdx = -1;
                        for (int j = 0; j < blocks; j++) {
                            if (blockSize[j] >= processSize[i]) {
                                if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx])
                                    worstIdx = j;
                            }
                        }
                        if (worstIdx != -1) {
                            allocation[i] = worstIdx;
                            blockSize[worstIdx] -= processSize[i];
                        }
                    }
                
                    printf("\nWorst Fit Allocation:\n");
                    for (int i = 0; i < processes; i++) {
                        printf("Process %d -> ", i + 1);
                        if (allocation[i] != -1)
                            printf("Block %d\n", allocation[i] + 1);
                        else
                            printf("Not Allocated\n");
                    }
                
                    calculateExternalFragmentation(blockSize, blocks, allocation, processes);
                }
                
                int main() {
                    int blocks, processes;
                    int blockSize[MAX], processSize[MAX];
                    int originalBlockSize[MAX];
                
                    printf("Enter number of free memory blocks: ");
                    scanf("%d", &blocks);
                    printf("Enter size of each block:\n");
                    for (int i = 0; i < blocks; i++) {
                        scanf("%d", &blockSize[i]);
                        originalBlockSize[i] = blockSize[i]; // Save original for reuse
                    }
                
                    printf("Enter number of processes: ");
                    scanf("%d", &processes);
                    printf("Enter size of each process:\n");
                    for (int i = 0; i < processes; i++)
                        scanf("%d", &processSize[i]);
                
                    // Call all strategies
                    for (int i = 0; i < blocks; i++) blockSize[i] = originalBlockSize[i];
                    firstFit(blockSize, blocks, processSize, processes);
                
                    for (int i = 0; i < blocks; i++) blockSize[i] = originalBlockSize[i];
                    nextFit(blockSize, blocks, processSize, processes);
                
                    for (int i = 0; i < blocks; i++) blockSize[i] = originalBlockSize[i];
                    bestFit(blockSize, blocks, processSize, processes);
                
                    for (int i = 0; i < blocks; i++) blockSize[i] = originalBlockSize[i];
                    worstFit(blockSize, blocks, processSize, processes);
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code10')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">address conversion</div>
        <textarea class="code-area" id="code11" readonly>
            #include <stdio.h>
                #include <stdlib.h>
                
                int main() {
                    int choice;
                    printf("Select mode:\n1. Paging\n2. Segmentation\nEnter choice: ");
                    scanf("%d", &choice);
                
                    if (choice == 1) {
                        // Paging
                        int *pageTable, numPages, pageSize, logicalAddress, pageNumber, offset, physicalAddress;
                
                        printf("\n--- Paging Mode ---\n");
                        printf("Enter number of pages: ");
                        scanf("%d", &numPages);
                
                        pageTable = (int *)malloc(numPages * sizeof(int)); // dynamic memory allocation
                
                        printf("Enter page size: ");
                        scanf("%d", &pageSize);
                
                        printf("Enter page table (frame numbers for each page):\n");
                        for (int i = 0; i < numPages; i++) {
                            printf("Page %d -> Frame: ", i);
                            scanf("%d", &pageTable[i]);
                        }
                
                        printf("Enter logical address: ");
                        scanf("%d", &logicalAddress);
                
                        pageNumber = logicalAddress / pageSize;
                        offset = logicalAddress % pageSize;
                
                        if (pageNumber >= numPages) {
                            printf("Error: Invalid page number.\n");
                        } else {
                            physicalAddress = pageTable[pageNumber] * pageSize + offset;
                            printf("Physical Address: %d\n", physicalAddress);
                        }
                
                        free(pageTable); // free dynamically allocated memory
                    }
                
                    else if (choice == 2) {
                        // Segmentation
                        int base[5], limit[5], segmentNumber, offset, physicalAddress;
                
                        printf("\n--- Segmentation Mode ---\n");
                        printf("Enter base and limit for 5 segments:\n");
                        for (int i = 0; i < 5; i++) {
                            printf("Segment %d - Base: ", i);
                            scanf("%d", &base[i]);
                            printf("Segment %d - Limit: ", i);
                            scanf("%d", &limit[i]);
                        }
                
                        printf("Enter segment number and offset: ");
                        scanf("%d%d", &segmentNumber, &offset);
                
                        if (segmentNumber < 5 && offset < limit[segmentNumber]) {
                            physicalAddress = base[segmentNumber] + offset;
                            printf("Physical Address: %d\n", physicalAddress);
                        } else {
                            printf("Error: Invalid segment number or offset exceeds limit.\n");
                        }
                    }
                
                    else {
                        printf("Invalid choice.\n");
                    }
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code11')">Copy</button>
    </div>
 
    <div class="code-block">
        <div class="code-heading">bankers algorithm</div>
        <textarea class="code-area" id="code12" readonly>
            #include <stdio.h>
                #include <stdbool.h>
                
                int main() {
                    int P, R;
                    printf("Enter number of processes: ");
                    scanf("%d", &P);
                    printf("Enter number of resources: ");
                    scanf("%d", &R);
                
                    int allocation[P][R], max[P][R], available[R]
                    , need[P][R];
                    bool finished[P];
                    int safeSequence[P], count = 0;
                
                    printf("Enter Allocation Matrix (%d x %d):\n", P, R);
                    for (int i = 0; i < P; i++)
                        for (int j = 0; j < R; j++)
                            scanf("%d", &allocation[i][j]);
                
                    printf("Enter Max Matrix (%d x %d):\n", P, R);
                    for (int i = 0; i < P; i++)
                        for (int j = 0; j < R; j++)
                            scanf("%d", &max[i][j]);
                
                    printf("Enter Available Resources (%d values):\n", R);
                    for (int i = 0; i < R; i++)
                        scanf("%d", &available[i]);
                
                    for (int i = 0; i < P; i++) {
                        finished[i] = false;
                        for (int j = 0; j < R; j++)
                            need[i][j] = max[i][j] - allocation[i][j];
                    }
                
                    printf("\n--- Banker's Algorithm Execution ---\n");
                    while (count < P) {
                        bool found = false;
                        for (int i = 0; i < P; i++) {
                            if (!finished[i]) {
                                bool canExecute = true;
                                for (int j = 0; j < R; j++) {
                                    if (need[i][j] > available[j]) {
                                        canExecute = false;
                                        break;
                                    }
                                }
                
                                if (canExecute) {
                                    for (int j = 0; j < R; j++)
                                        available[j] += allocation[i][j];
                
                                    finished[i] = true;
                                    safeSequence[count++] = i;
                
                                    printf("P%d executed. Available: ", i);
                                    for (int j = 0; j < R; j++)
                                        printf("%d ", available[j]);
                                    printf("\n");
                
                                    found = true;
                                    break;
                                }
                            }
                        }
                
                        if (!found) {
                            printf("System is in Deadlock! No safe sequence.\n");
                            return 0;
                        }
                    }
                
                    printf("\nSystem is in a Safe State.\nSafe Sequence: ");
                    for (int i = 0; i < P; i++)
                        printf("P%d ", safeSequence[i]);
                    printf("\n");
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code12')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">deadlock detection</div>
        <textarea class="code-area" id="code13" readonly>
            #include <stdio.h>
                #include <stdbool.h>
                
                int main() {
                    int N, M;
                
                    // User input for number of processes and resources
                    printf("Enter number of processes: ");
                    scanf("%d", &N);
                    printf("Enter number of resource types: ");
                    scanf("%d", &M);
                
                    int Allocation[N][M], Max[N][M], Available[M], Need[N][M];
                    bool Finish[N];
                    int Work[M];
                
                    // User input for Allocation Matrix
                    printf("Enter Allocation Matrix (%d x %d):\n", N, M);
                    for (int i = 0; i < N; i++)
                        for (int j = 0; j < M; j++)
                            scanf("%d", &Allocation[i][j]);
                
                    // User input for Max Matrix
                    printf("Enter Max Matrix (%d x %d):\n", N, M);
                    for (int i = 0; i < N; i++)
                        for (int j = 0; j < M; j++)
                            scanf("%d", &Max[i][j]);
                
                    // User input for Available Resources
                    printf("Enter Available Resources (%d values):\n", M);
                    for (int i = 0; i < M; i++)
                        scanf("%d", &Available[i]);
                
                    // Step 1: Calculate Need = Max - Allocation
                    for (int i = 0; i < N; i++)
                        for (int j = 0; j < M; j++)
                            Need[i][j] = Max[i][j] - Allocation[i][j];
                
                    // Step 2: Initialize Work = Available
                    for (int i = 0; i < M; i++)
                        Work[i] = Available[i];
                
                    // Step 3: Try to find processes that can finish
                    bool foundProcess;
                    do {
                        foundProcess = false;
                        for (int i = 0; i < N; i++) {
                            if (!Finish[i]) {
                                bool canRun = true;
                                for (int j = 0; j < M; j++) {
                                    if (Need[i][j] > Work[j]) {
                                        canRun = false;
                                        break;
                                    }
                                }
                                if (canRun) {
                                    for (int j = 0; j < M; j++)
                                        Work[j] += Allocation[i][j];
                
                                    Finish[i] = true;
                                    foundProcess = true;
                                    printf("Process P%d has completed.\n", i);
                                }
                            }
                        }
                    } while (foundProcess);
                
                    // Step 4: Check if any process is still unfinished
                    bool deadlock = false;
                    for (int i = 0; i < N; i++) {
                        if (!Finish[i]) {
                            deadlock = true;
                            printf("Process P%d is in deadlock.\n", i);
                        }
                    }
                
                    if (!deadlock)
                        printf("No Deadlock detected. System is in safe state.\n");
                    else
                        printf("Deadlock detected in the system.\n");
                
                    return 0;
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code13')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">fcfs and round robin</div>
        <textarea class="code-area" id="code14" readonly>
            #include <stdio.h>

                // Function to calculate Completion Time, Turnaround Time, and Waiting Time
                void findTimes(int processes[], int n, int at[], int bt[], int ct[], int tat[], int wt[]) {
                    ct[0] = at[0] + bt[0];
                    for (int i = 1; i < n; i++) {
                        if (at[i] > ct[i - 1]) {
                            ct[i] = at[i] + bt[i]; // CPU was idle
                        } else {
                            ct[i] = ct[i - 1] + bt[i]; // CPU starts immediately after last process
                        }
                    }
                
                    for (int i = 0; i < n; i++) {
                        tat[i] = ct[i] - at[i];
                        wt[i] = tat[i] - bt[i];
                    }
                }
                
                // Function to print Gantt Chart
                void printGanttChart(int processes[], int ct[], int at[], int n) {
                    printf("\nGantt Chart:\n");
                
                    // Top bar
                    printf(" ");
                    for (int i = 0; i < n; i++) {
                        printf("--------");
                    }
                    printf("\n|");
                
                    // Process names
                    for (int i = 0; i < n; i++) {
                        printf("  P%d   |", processes[i]);
                    }
                
                    // Bottom bar
                    printf("\n ");
                    for (int i = 0; i < n; i++) {
                        printf("--------");
                    }
                
                    // Timeline
                    printf("\n");
                    int start;
                    for (int i = 0; i < n; i++) {
                        if (i == 0 || at[i] > ct[i - 1]) {
                            start = at[i];
                        } else {
                            start = ct[i - 1];
                        }
                        printf("%-8d", start);
                    }
                    printf("%d\n", ct[n - 1]); // Last completion time
                }
                
                // Function to print the full result table and averages
                void findavgTime(int processes[], int n, int at[], int bt[]) {
                    int ct[n], tat[n], wt[n];
                    int total_wt = 0, total_tat = 0;
                
                    findTimes(processes, n, at, bt, ct, tat, wt);
                
                    printf("\n--------------------------------------------------------------------------------\n");
                    printf("| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |\n");
                    printf("--------------------------------------------------------------------------------\n");
                
                    for (int i = 0; i < n; i++) {
                        total_wt += wt[i];
                        total_tat += tat[i];
                        printf("|   P%d    |      %2d       |     %2d     |       %2d        |       %2d       |      %2d      |\n",
                               processes[i], at[i], bt[i], ct[i], tat[i], wt[i]);
                    }
                
                    printf("--------------------------------------------------------------------------------\n");
                    float avg_wt = (float) total_wt / n;
                    float avg_tat = (float) total_tat / n;
                    printf("Average Waiting Time    = %.2f\n", avg_wt);
                    printf("Average Turnaround Time = %.2f\n", avg_tat);
                
                    printGanttChart(processes, ct, at, n);
                }
                
                // Main function with input from user
                int main() {
                    int n;
                    printf("Enter number of processes: ");
                    scanf("%d", &n);
                
                    int processes[n], at[n], bt[n];
                
                    // Input process data
                    for (int i = 0; i < n; i++) {
                        processes[i] = i + 1;
                        printf("Enter Arrival Time for Process %d: ", i + 1);
                        scanf("%d", &at[i]);
                        printf("Enter Burst Time for Process %d: ", i + 1);
                        scanf("%d", &bt[i]);
                    }
                
                    findavgTime(processes, n, at, bt);
                    return 0;
                }

                #include <stdio.h>
                    #include <stdbool.h>
                    
                    // Function to display the Gantt Chart
                    void displayGanttChart(int gantt[], int ganttLen) {
                        printf("\nGantt Chart:\n ");
                        for (int i = 0; i < ganttLen; i++) {
                            printf("----");
                        }
                        printf("-\n|");
                    
                        for (int i = 0; i < ganttLen; i++) {
                            if (gantt[i] == -1)
                                printf(" I |"); // Idle
                            else
                                printf("P%d |", gantt[i]);
                        }
                    
                        printf("\n ");
                        for (int i = 0; i < ganttLen; i++) {
                            printf("----");
                        }
                        printf("-\n");
                    
                        printf("0");
                        for (int i = 1; i <= ganttLen; i++) {
                            printf("   %d", i);
                        }
                        printf("\n");
                    }
                    
                    // Round Robin Scheduler Function
                    void roundRobin(int n, int pid[], int at[], int bt[], int tq) {
                        int rt[n], wt[n], tat[n], ct[n];
                        for (int i = 0; i < n; i++) rt[i] = bt[i];
                    
                        int time = 0, completed = 0;
                        bool visited[n];
                        for (int i = 0; i < n; i++) visited[i] = false;
                    
                        int gantt[1000], ganttLen = 0;
                    
                        while (completed < n) {
                            bool found = false;
                            for (int i = 0; i < n; i++) {
                                if (at[i] <= time && rt[i] > 0) {
                                    found = true;
                                    int execTime = (rt[i] > tq) ? tq : rt[i];
                                    for (int j = 0; j < execTime; j++)
                                        gantt[ganttLen++] = pid[i]; // Record each time unit in Gantt chart
                    
                                    time += execTime;
                                    rt[i] -= execTime;
                    
                                    if (rt[i] == 0) {
                                        completed++;
                                        ct[i] = time;
                                        tat[i] = ct[i] - at[i];
                                        wt[i] = tat[i] - bt[i];
                                    }
                                }
                            }
                    
                            if (!found) {
                                gantt[ganttLen++] = -1; // Idle time
                                time++;
                            }
                        }
                    
                        // Display output
                        int total_wt = 0, total_tat = 0;
                        printf("--------------------------------------------------------------\n");
                        printf("| PID | Arrival | Burst | Completion | Turnaround | Waiting |\n");
                        printf("--------------------------------------------------------------\n");
                    
                        for (int i = 0; i < n; i++) {
                            printf("| P%-2d |   %2d    |  %2d   |     %2d     |     %2d     |   %2d    |\n",
                                   pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
                            total_wt += wt[i];
                            total_tat += tat[i];
                        }
                    
                        printf("--------------------------------------------------------------\n");
                        printf("Average Waiting Time    : %.2f\n", (float)total_wt / n);
                        printf("Average Turnaround Time : %.2f\n", (float)total_tat / n);
                    
                        displayGanttChart(gantt, ganttLen);
                    }
                    
                    // Main Function
                    int main() {
                        int n;
                        printf("Enter number of processes: ");
                        scanf("%d", &n);
                    
                        int pid[n], at[n], bt[n], tq;
                    
                        for (int i = 0; i < n; i++) {
                            pid[i] = i + 1;
                            printf("Enter Arrival Time for Process P%d: ", pid[i]);
                            scanf("%d", &at[i]);
                            printf("Enter Burst Time for Process P%d: ", pid[i]);
                            scanf("%d", &bt[i]);
                        }
                    
                        printf("Enter Time Quantum: ");
                        scanf("%d", &tq);
                    
                        roundRobin(n, pid, at, bt, tq);
                    
                        return 0;
                    }                    

        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code14')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">preemptive non preemptive priority</div>
        <textarea class="code-area" id="code15" readonly>
            #include <stdio.h>
                #include <stdbool.h>
                
                #define MAX 100
                
                int main() {
                    int n;
                    int pid[MAX], at[MAX], bt[MAX], priority[MAX];
                    int rt[MAX], ct[MAX], tat[MAX], wt[MAX];
                    bool completed[MAX] = {false};
                
                    printf("Enter the number of processes: ");
                    scanf("%d", &n);
                
                    for (int i = 0; i < n; i++) {
                        pid[i] = i + 1;
                        printf("Enter Arrival Time for Process P%d: ", pid[i]);
                        scanf("%d", &at[i]);
                        printf("Enter Burst Time for Process P%d: ", pid[i]);
                        scanf("%d", &bt[i]);
                        printf("Enter Priority for Process P%d (lower number = higher priority): ", pid[i]);
                        scanf("%d", &priority[i]);
                    }
                
                    for (int i = 0; i < n; i++) {
                        rt[i] = bt[i];
                    }
                
                    int completedCount = 0, time = 0;
                    int gantt[MAX], ganttTime[MAX], gIndex = 0;
                
                    while (completedCount < n) {
                        int idx = -1;
                        int highestPriority = 9999;
                
                        for (int i = 0; i < n; i++) {
                            if (at[i] <= time && rt[i] > 0 && priority[i] < highestPriority) {
                                highestPriority = priority[i];
                                idx = i;
                            }
                        }
                
                        if (idx != -1) {
                            rt[idx]--;
                
                            // Record in Gantt chart
                            gantt[gIndex] = pid[idx];
                            ganttTime[gIndex] = time;
                            gIndex++;
                
                            if (rt[idx] == 0) {
                                completed[idx] = true;
                                completedCount++;
                                ct[idx] = time + 1;
                            }
                        } else {
                            // Idle time
                            gantt[gIndex] = -1;
                            ganttTime[gIndex] = time;
                            gIndex++;
                        }
                
                        time++;
                    }
                
                    for (int i = 0; i < n; i++) {
                        tat[i] = ct[i] - at[i];
                        wt[i] = tat[i] - bt[i];
                    }
                
                    printf("----------------------------------------------------------------------------\n");
                    printf("| PID | Arrival | Burst | Priority | Completion | Turnaround | Waiting    |\n");
                    printf("----------------------------------------------------------------------------\n");
                
                    float avg_tat = 0, avg_wt = 0;
                    for (int i = 0; i < n; i++) {
                        printf("| P%-2d |   %2d    |   %2d  |    %2d    |     %2d     |     %2d     |    %2d     |\n",
                               pid[i], at[i], bt[i], priority[i], ct[i], tat[i], wt[i]);
                
                        avg_tat += tat[i];
                        avg_wt += wt[i];
                    }
                    printf("----------------------------------------------------------------------------\n");
                    printf("Average Turnaround Time = %.2f\n", avg_tat / n);
                    printf("Average Waiting Time = %.2f\n", avg_wt / n);
                
                    // Gantt Chart
                    printf("\nGantt Chart:\n|");
                    for (int i = 0; i < gIndex; i++) {
                        if (gantt[i] == -1)
                            printf(" IDLE |");
                        else
                            printf(" P%d |", gantt[i]);
                    }
                    printf("\n");
                
                    for (int i = 0; i < gIndex; i++) {
                        printf("%-5d", ganttTime[i]);
                    }
                    printf("%-5d\n", time);  // Final time
                
                    return 0;
                }

            
                #include <stdio.h>
                    #include <stdbool.h>
                    
                    #define MAX 100
                    
                    void calculateTimes(int n, int at[], int bt[], int ct[], int tat[], int wt[], int priority[], int pid[], int gantt[], int startTimes[], int *ganttSize) {
                        int remaining_bt[MAX], currentTime = 0, completed = 0;
                        bool isStarted[MAX] = {false};
                    
                        for (int i = 0; i < n; i++) {
                            remaining_bt[i] = bt[i];
                        }
                    
                        int lastProcess = -1;
                        *ganttSize = 0;
                    
                        while (completed < n) {
                            int idx = -1;
                            int minPriority = 9999;
                    
                            for (int i = 0; i < n; i++) {
                                if (at[i] <= currentTime && remaining_bt[i] > 0) {
                                    if (priority[i] < minPriority || (priority[i] == minPriority && at[i] < at[idx])) {
                                        minPriority = priority[i];
                                        idx = i;
                                    }
                                }
                            }
                    
                            if (idx != -1) {
                                if (!isStarted[idx]) {
                                    isStarted[idx] = true;
                                }
                    
                                // Add to Gantt chart if process changes
                                if (lastProcess != idx) {
                                    gantt[*ganttSize] = pid[idx];
                                    startTimes[*ganttSize] = currentTime;
                                    (*ganttSize)++;
                                    lastProcess = idx;
                                }
                    
                                remaining_bt[idx]--;
                                currentTime++;
                    
                                if (remaining_bt[idx] == 0) {
                                    ct[idx] = currentTime;
                                    tat[idx] = ct[idx] - at[idx];
                                    wt[idx] = tat[idx] - bt[idx];
                                    completed++;
                                }
                            } else {
                                currentTime++;
                            }
                        }
                    
                        startTimes[*ganttSize] = currentTime; // End time for the last process
                    }
                    
                    void printTable(int n, int pid[], int at[], int bt[], int priority[], int ct[], int tat[], int wt[]) {
                        printf("\nProcess\tAT\tBT\tPR\tCT\tTAT\tWT\n");
                        for (int i = 0; i < n; i++) {
                            printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n", pid[i], at[i], bt[i], priority[i], ct[i], tat[i], wt[i]);
                        }
                    }
                    
                    void printGanttChart(int gantt[], int startTimes[], int size) {
                        printf("\nGantt Chart:\n|");
                        for (int i = 0; i < size; i++) {
                            printf(" P%d |", gantt[i]);
                        }
                        printf("\n");
                    
                        printf("%d", startTimes[0]);
                        for (int i = 1; i <= size; i++) {
                            printf("   %d", startTimes[i]);
                        }
                        printf("\n");
                    }
                    
                    int main() {
                        int n;
                    
                        printf("Enter number of processes: ");
                        scanf("%d", &n);
                    
                        int pid[MAX], at[MAX], bt[MAX], priority[MAX];
                        int ct[MAX], tat[MAX], wt[MAX];
                        int gantt[MAX], startTimes[MAX];
                        int ganttSize;
                    
                        for (int i = 0; i < n; i++) {
                            pid[i] = i + 1;
                            printf("Enter Arrival Time, Burst Time, and Priority for P%d: ", pid[i]);
                            scanf("%d %d %d", &at[i], &bt[i], &priority[i]);
                        }
                    
                        calculateTimes(n, at, bt, ct, tat, wt, priority, pid, gantt, startTimes, &ganttSize);
                    
                        printTable(n, pid, at, bt, priority, ct, tat, wt);
                        printGanttChart(gantt, startTimes, ganttSize);
                    
                        return 0;
                    }                    
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code15')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">srf non preemptive and preemptive</div>
        <textarea class="code-area" id="code16" readonly>
            #include <stdio.h>
                #include <stdbool.h>
                
                // Global arrays to store actual execution order and time for Gantt Chart
                int executionOrder[100];
                int executionEndTime[100];
                
                // Swap utility
                void swap(int *a, int *b) {
                    int temp = *a;
                    *a = *b;
                    *b = temp;
                }
                
                // Sort processes by Arrival Time, then by Burst Time
                void sortByArrivalAndBurst(int n, int at[], int bt[], int pid[]) {
                    for (int i = 0; i < n - 1; i++) {
                        for (int j = 0; j < n - i - 1; j++) {
                            if (at[j] > at[j + 1] || (at[j] == at[j + 1] && bt[j] > bt[j + 1])) {
                                swap(&at[j], &at[j + 1]);
                                swap(&bt[j], &bt[j + 1]);
                                swap(&pid[j], &pid[j + 1]);
                            }
                        }
                    }
                }
                
                // Calculate Completion Time, Turnaround Time, Waiting Time and Execution Order
                void calculateTimes(int n, int at[], int bt[], int ct[], int tat[], int wt[], int pid[]) {
                    bool completed[n];
                    for (int i = 0; i < n; i++) completed[i] = false;
                
                    int completedCount = 0, currentTime = 0, index = 0;
                
                    while (completedCount < n) {
                        int shortestJob = -1, minBurstTime = 9999;
                
                        for (int i = 0; i < n; i++) {
                            if (!completed[i] && at[i] <= currentTime && bt[i] < minBurstTime) {
                                minBurstTime = bt[i];
                                shortestJob = i;
                            }
                        }
                
                        if (shortestJob == -1) {
                            currentTime++;
                        } else {
                            currentTime += bt[shortestJob];
                            ct[shortestJob] = currentTime;
                            tat[shortestJob] = ct[shortestJob] - at[shortestJob];
                            wt[shortestJob] = tat[shortestJob] - bt[shortestJob];
                            completed[shortestJob] = true;
                
                            executionOrder[index] = shortestJob;
                            executionEndTime[index] = currentTime;
                            index++;
                
                            completedCount++;
                        }
                    }
                }
                
                // Display Table of Results
                void displayResults(int n, int pid[], int at[], int bt[], int ct[], int tat[], int wt[]) {
                    int total_wt = 0, total_tat = 0;
                
                    printf("-----------------------------------------------------------------\n");
                    printf("| Process | Arrival Time | Burst Time | Completion Time | TAT | WT |\n");
                    printf("-----------------------------------------------------------------\n");
                
                    for (int i = 0; i < n; i++) {
                        printf("|   P%-2d   |      %2d      |     %2d     |       %2d       | %2d  | %2d |\n",
                               pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
                        total_wt += wt[i];
                        total_tat += tat[i];
                    }
                    printf("-----------------------------------------------------------------\n");
                    printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
                    printf("Average Turnaround Time: %.2f\n", (float)total_tat / n);
                }
                
                // Accurate Gantt Chart based on actual execution order
                void printGanttChart(int n, int pid[], int at[], int bt[]) {
                    printf("\nGantt Chart:\n|");
                    for (int i = 0; i < n; i++) {
                        printf(" P%d |", pid[executionOrder[i]]);
                    }
                    printf("\n");
                
                    printf("0");
                    for (int i = 0; i < n; i++) {
                        printf("   %d", executionEndTime[i]);
                    }
                    printf("\n");
                }
                
                int main() {
                    int n;
                    printf("Enter number of processes: ");
                    scanf("%d", &n);
                
                    int pid[n], at[n], bt[n], ct[n], tat[n], wt[n];
                
                    for (int i = 0; i < n; i++) {
                        pid[i] = i + 1;
                        printf("Enter Arrival Time and Burst Time for Process %d: ", pid[i]);
                        scanf("%d %d", &at[i], &bt[i]);
                    }
                
                    sortByArrivalAndBurst(n, at, bt, pid);
                    calculateTimes(n, at, bt, ct, tat, wt, pid);
                    displayResults(n, pid, at, bt, ct, tat, wt);
                    printGanttChart(n, pid, at, bt);
                
                    return 0;
                }
        
                #include <stdio.h>
                    #include <stdbool.h>
                    
                    void swap(int *a, int *b) {
                        int temp = *a;
                        *a = *b;
                        *b = temp;
                    }
                    
                    void sortByArrivalAndBurst(int n, int at[], int bt[], int pid[]) {
                        for (int i = 0; i < n - 1; i++) {
                            for (int j = 0; j < n - i - 1; j++) {
                                if (at[j] > at[j + 1] || (at[j] == at[j + 1] && bt[j] > bt[j + 1])) {
                                    swap(&at[j], &at[j + 1]);
                                    swap(&bt[j], &bt[j + 1]);
                                    swap(&pid[j], &pid[j + 1]);
                                }
                            }
                        }
                    }
                    
                    // Tracks the Gantt chart timeline
                    void calculateTimes(int n, int at[], int bt[], int ct[], int tat[], int wt[], int timeline[], int *timelineLength) {
                        bool completed[n];
                        int remainingBt[n];
                        for (int i = 0; i < n; i++) {
                            completed[i] = false;
                            remainingBt[i] = bt[i];
                        }
                    
                        int completedCount = 0, currentTime = 0;
                        *timelineLength = 0;
                    
                        while (completedCount < n) {
                            int shortestJob = -1, minBurstTime = 9999;
                    
                            for (int i = 0; i < n; i++) {
                                if (!completed[i] && at[i] <= currentTime && remainingBt[i] < minBurstTime && remainingBt[i] > 0) {
                                    minBurstTime = remainingBt[i];
                                    shortestJob = i;
                                }
                            }
                    
                            if (shortestJob == -1) {
                                timeline[(*timelineLength)++] = -1; // idle time
                                currentTime++;
                            } else {
                                timeline[(*timelineLength)++] = shortestJob; // store index
                                remainingBt[shortestJob]--;
                                currentTime++;
                    
                                if (remainingBt[shortestJob] == 0) {
                                    completed[shortestJob] = true;
                                    ct[shortestJob] = currentTime;
                                    tat[shortestJob] = ct[shortestJob] - at[shortestJob];
                                    wt[shortestJob] = tat[shortestJob] - bt[shortestJob];
                                    completedCount++;
                                }
                            }
                        }
                    }
                    
                    void displayResults(int n, int pid[], int at[], int bt[], int ct[], int tat[], int wt[]) {
                        int total_wt = 0, total_tat = 0;
                    
                        printf("-----------------------------------------------------------------\n");
                        printf("| Process | Arrival Time | Burst Time | Completion Time | TAT  | WT  |\n");
                        printf("-----------------------------------------------------------------\n");
                    
                        for (int i = 0; i < n; i++) {
                            printf("|   P%-2d   |      %2d      |     %2d     |       %2d       |  %2d  | %2d  |\n",
                                   pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
                    
                            total_wt += wt[i];
                            total_tat += tat[i];
                        }
                        printf("-----------------------------------------------------------------\n");
                    
                        printf("Average Waiting Time: %.2f\n", (float)total_wt / n);
                        printf("Average Turnaround Time: %.2f\n", (float)total_tat / n);
                    }
                    
                    void displayGanttChart(int timeline[], int timelineLength, int pid[]) {
                        printf("\nGantt Chart:\n");
                        printf(" ");
                    
                        // Top border
                        for (int i = 0; i < timelineLength; i++) printf("----");
                        printf("-\n|");
                    
                        // Process names
                        for (int i = 0; i < timelineLength; i++) {
                            if (timeline[i] == -1)
                                printf(" I |");
                            else
                                printf("P%d |", pid[timeline[i]]);
                        }
                    
                        // Bottom border
                        printf("\n ");
                        for (int i = 0; i < timelineLength; i++) printf("----");
                        printf("-\n");
                    
                        // Time labels
                        printf("0");
                        for (int i = 1; i <= timelineLength; i++) printf("   %d", i);
                        printf("\n");
                    }
                    
                    int main() {
                        int n;
                        printf("Enter number of processes: ");
                        scanf("%d", &n);
                    
                        int pid[n], at[n], bt[n], ct[n], tat[n], wt[n], timeline[1000], timelineLength;
                    
                        for (int i = 0; i < n; i++) {
                            pid[i] = i + 1;
                            printf("Enter Arrival Time of P%d: ", i + 1);
                            scanf("%d", &at[i]);
                            printf("Enter Burst Time of P%d: ", i + 1);
                            scanf("%d", &bt[i]);
                        }
                    
                        sortByArrivalAndBurst(n, at, bt, pid);
                        calculateTimes(n, at, bt, ct, tat, wt, timeline, &timelineLength);
                        displayResults(n, pid, at, bt, ct, tat, wt);
                        displayGanttChart(timeline, timelineLength, pid);
                    
                        return 0;
                    }                    
                     </textarea>
        <button class="copy-button" onclick="copyToClipboard('code16')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">buddy system</div>
        <textarea class="code-area" id="code17" readonly>
            #include <stdio.h>
                #include <math.h>
                
                #define MAX 1024  // Total memory size (must be power of 2)
                
                struct Block {
                    int size;
                    int isFree;
                };
                
                struct Block memory[MAX];
                
                // Initialize memory with one big free block
                void initialize() {
                    memory[0].size = MAX;
                    memory[0].isFree = 1;
                    for (int i = 1; i < MAX; i++) {
                        memory[i].size = 0;
                        memory[i].isFree = 0;
                    }
                }
                
                // Find next power of 2 >= n
                int nextPowerOf2(int n) {
                    int p = 1;
                    while (p < n) p *= 2;
                    return p;
                }
                
                // Find the buddy block index
                int buddyIndex(int index, int blockSize) {
                    return index ^ blockSize;
                }
                
                // Allocate memory
                void allocate(int reqSize) {
                    int size = nextPowerOf2(reqSize);  // Find the smallest power of 2 >= requested size
                    for (int i = 0; i < MAX; i++) {
                        if (memory[i].isFree && memory[i].size >= size) {
                            // Split the block until its size is the requested size
                            while (memory[i].size > size) {
                                int half = memory[i].size / 2;
                                memory[i].size = half;
                                memory[i + half].size = half;
                                memory[i + half].isFree = 1;
                            }
                            memory[i].isFree = 0;  // Mark the block as used
                            printf("Allocated %d bytes at index %d\n", size, i);
                            return;
                        }
                    }
                    printf("Allocation failed. Not enough memory.\n");
                }
                
                // Free memory
                void freeMemory(int index) {
                    if (index < 0 || index >= MAX || memory[index].size == 0) {
                        printf("Invalid index.\n");
                        return;
                    }
                
                    memory[index].isFree = 1;  // Mark the block as free
                    int blockSize = memory[index].size;
                    int buddy = buddyIndex(index, blockSize);
                
                    // Attempt to merge the buddy blocks
                    while (buddy < MAX && memory[buddy].isFree && memory[buddy].size == blockSize) {
                        // Merge with the buddy block if they are both free and of the same size
                        memory[index].size *= 2;  // Double the size of the current block
                        memory[buddy].size = 0;  // Mark the buddy block as unused
                        memory[buddy].isFree = 0;
                        if (buddy < index) index = buddy;  // Update the index if the buddy is smaller
                        buddy = buddyIndex(index, memory[index].size);  // Calculate new buddy index
                    }
                    printf("Freed memory at index %d\n", index);
                }
                
                // Show memory status
                void showMemory() {
                    printf("\nMemory Blocks:\n");
                    for (int i = 0; i < MAX; i++) {
                        if (memory[i].size > 0) {
                            printf("Index: %3d | Size: %4d | %s\n", i, memory[i].size, memory[i].isFree ? "Free" : "Used");
                        }
                    }
                    printf("\n");
                }
                
                // Main function with user input
                int main() {
                    initialize();
                    int choice, size, index;
                
                    while (1) {
                        printf("\n--- Buddy System Menu ---\n");
                        printf("1. Allocate Memory\n");
                        printf("2. Free Memory\n");
                        printf("3. Show Memory\n");
                        printf("4. Exit\n");
                        printf("Enter your choice: ");
                        scanf("%d", &choice);
                
                        switch (choice) {
                            case 1:
                                printf("Enter size to allocate: ");
                                scanf("%d", &size);
                                allocate(size);
                                break;
                            case 2:
                                printf("Enter index to free: ");
                                scanf("%d", &index);
                                freeMemory(index);
                                break;
                            case 3:
                                showMemory();
                                break;
                            case 4:
                                printf("Exiting...\n");
                                return 0;
                            default:
                                printf("Invalid choice. Try again.\n");
                        }
                    }
                }                
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code17')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">os load phase 1</div>
        <textarea class="code-area" id="code18" readonly>
            #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                
                #define BUFFER_SIZE 40
                #define MEMORY_ROWS 100
                #define MEMORY_COLS 4
                
                char buffer[BUFFER_SIZE];
                char Memory[MEMORY_ROWS][MEMORY_COLS];
                FILE *infile;
                
                void init()
                {
                    memset(buffer, '\0', sizeof(buffer));
                    memset(Memory, '\0', sizeof(Memory));
                }
                
                void resetBuffer()
                {
                    memset(buffer, '\0', sizeof(buffer));
                }
                
                void LOAD()
                {
                    infile = fopen("input.txt", "r");
                    if (infile == NULL)
                    {
                        printf("Error opening input file\n");
                        return;
                    }
                
                    char s[BUFFER_SIZE];
                    int IC = 0;
                
                    while (fgets(s, sizeof(s), infile))
                    {
                        if (strncmp(s, "$AMJ", 4) == 0)
                        {
                            init();
                            printf("\nNew Job started\n");
                        }
                        else if (strncmp(s, "$DTA", 4) == 0)
                        {
                            printf("Data card loading\n");
                            resetBuffer();
                        }
                        else if (strncmp(s, "$END", 4) == 0)
                        {
                            printf("END of Job\n");
                        }
                        else
                        {
                            printf("Program Card loading\n");
                            resetBuffer();
                            strncpy(buffer, s, BUFFER_SIZE);
                
                            int buff = 0;
                            while (buff < BUFFER_SIZE && buffer[buff] != '\0')
                            {
                                for (int j = 0; j < MEMORY_COLS; j++)
                                {
                                    if (buffer[buff] == 'H')
                                    {
                                        Memory[IC][j] = 'H';
                                        buff++;
                                        break;
                                    }
                                    Memory[IC][j] = buffer[buff];
                                    buff++;
                                }
                                IC++;
                            }
                        }
                    }
                
                    fclose(infile);
                }
                
                int main()
                {
                    LOAD();
                    return 0;
                }
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code18')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">SHELL SCRIPTING</div>
        <textarea class="code-area" id="code19" readonly>
            #!/bin/bash

echo "Enter a number:"
read num

# 1️⃣ Check Palindrome
rev=0
temp=$num

while [ $temp -gt 0 ]
do
    rem=$((temp % 10))
    rev=$((rev * 10 + rem))
    temp=$((temp / 10))
done

if [ $num -eq $rev ]; then
    echo "$num is a Palindrome number"
else
    echo "$num is NOT a Palindrome number"
fi


#!/bin/bash
echo "Enter a number:"
read num

# Convert number to individual digits
len=${#num}
echo -n "In words: "
for (( i=0; i<$len; i++ ))
do
  digit=${num:$i:1}
  case $digit in
    0) echo -n "Zero " ;;
    1) echo -n "One " ;;
    2) echo -n "Two " ;;
    3) echo -n "Three " ;;
    4) echo -n "Four " ;;
    5) echo -n "Five " ;;
    6) echo -n "Six " ;;
    7) echo -n "Seven " ;;
    8) echo -n "Eight " ;;
    9) echo -n "Nine " ;;
    *) echo -n "Invalid " ;;
  esac
done

echo    # Newline after output




# 2️⃣ Check Prime
flag=0
if [ $num -le 1 ]; then
    flag=1
else
    for (( i=2; i<=num/2; i++ ))
    do
        if [ $((num % i)) -eq 0 ]; then
            flag=1
            break
        fi
    done
fi

if [ $flag -eq 0 ]; then
    echo "$num is a Prime number"
else
    echo "$num is NOT a Prime number"
fi

REVERSE AND SUM
#!/bin/bash
echo "Enter a number:"
read num
rev=0
sum=0
temp=$num  # Save original number

while [ $num -gt 0 ]
do
  digit=$((num % 10))
  rev=$((rev * 10 + digit))
  sum=$((sum + digit))
  num=$((num / 10))
done

echo "Reversed number is $rev"
echo "Sum of digits is $sum"


# 3️⃣ Generate Fibonacci Series up to n terms
echo "Enter how many terms of Fibonacci series you want:"
read n

a=0
b=1
echo "Fibonacci Series:"
echo -n "$a $b "

for (( i=2; i<n; i++ ))
do
    fib=$((a + b))
    echo -n "$fib "
    a=$b
    b=$fib
done

echo
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code19')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">linux commands</div>
        <textarea class="code-area" id="code20" readonly>
            LINUX COMMANDS:
1.	Change your password to a password you would like to use for the remainder of the semester.
passwd

2.	Display the system’s date
date

3.	Count the number of lines in the /etc/passwd file
wc -l /etc/passwd

4.	Find out who else is on the system
who

5.	Direct the output of the man pages for the date command to a file named mydate
touch mydate.txt
man date > mydate.txt
cat mydate.txt

6.	Create a subdirectory called mydir
mkdir mydir

7.	Move the file mydate into the new subdirectory
mv mydate.txt mydir/

8.	Go to the subdirectory mydir and copy the file mydate to a new file called ourdate
cd mydir
cp mydate.txt ourdate.txt
cat ourdate.txt

9.	List the contents of mydir
ls mydir

10.	Do a long listing on the file ourdate and note the permissions
ls -l mydir

11.	Display the name of the current directory starting from the root.cd
pwd
12.	Move the files in the directory mydir back to your home directory
mv mydir/* ~/

13.	Display the first 5 lines of mydate
head -5 mydate

14.	Display the last 8 lines of mydate
tail -8 mydate

15.	Remove the directory mydir.
rm -r mydir or rmdir mydir

16.	Redirect the output of the long listing of files to a file named list
ls -l > list.txt

17.	Select any 5 capitals of states in India and enter them in a file named capitals1. Choose 5 more capitals and enter them in a file named capitals2. Choose 5 more capitals and enter them in a file named capitals3. Concatenate all 3 files and redirect the output to a file name capitals
echo -e “Amaravati\nitanagar\ndispur\patna\nraipur” > capitals1
echo -e “Panaji\nGandhinagar\nchandigarh\nshimla\nranchi” ? capitals2
echo -e “bengluru\nthiruvananthapuram\nbhopal\mumbai\nimphal” > capitals3
cat capitals1 capitals2 capitals3 > capitals

18.	Concatenate the file capitals2 at the end of file capitals
cat capitals2 >> capitals

19.	Give read and write permissions to all users for the file capitals
chmod -a+rw capitals

20.	Give read permissions only to the owner of the file capitals. Open the file, make some changes and try to save it. What happens
chmod 400 capitals

21.	Create an alias to concatenate the 3 files capitals1, capitals2, capitals3 and redirect the output to a file name capitals. Activate the alias and make it run.
alias concatcap=’cat capitals1 capitals 2 capitals3 > capitals’
concatcap

22.	Find out the number of times the string “the” appears in the file mydate
grep -o “date” mydate | wc -l
23.	Find out the line numbers on which the string “date” exists in mydate
grep -n “date” mydate

24.	Print all lines of mydate except those that have the letter “i” in them
grep -v “i” mydate

25.	List the words of 4 letters from the file mydate
grep -o -w ‘\w\{4\}’ my date

26.	List 5 states in north east India in a file mystates. List their corresponding capitals in a file mycapitals. Use the paste command to join the 2 files
echo -e "Assam\nArunachal Pradesh\nManipur\nMeghalaya\nTripura" > mystates
echo -e "Dispur\nItanagar\nImphal\nShillong\nAgartala" > mycapitals
paste mystates mycapitals

27.	Use the cut command to print the 1 st and 3 rd columns of the /etc/passwd file for all students in this class
cut -d: f1,3 /etc/passwd

28.	Count the number of people logged in and also trap the users in a file using the tee command
who | tee users | wc -l

29.	Convert the contents of mystates into uppercase
tr ‘a-z’ ‘A-Z’ < mystates

30.	Create any two files & display the common values between them
cat > file1
1
2
3
4
5
<ctrl+D>

cat > file2
2
4
6
8
10
<ctrl+D>

comm -12 <(sort file1) <(sort file2) 

        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code20')">Copy</button>
    </div>

    <div class="code-block">
        <div class="code-heading">Snippet 21 Title</div>
        <textarea class="code-area" id="code21" readonly>
        </textarea>
        <button class="copy-button" onclick="copyToClipboard('code21')">Copy</button>
    </div>

    <script>
        function copyToClipboard(elementId) {
            const textarea = document.getElementById(elementId);
            textarea.select();
            document.execCommand('copy');
            window.getSelection().removeAllRanges(); // Deselect the text
            // alert('Code copied!'); // Optional: Provide feedback
        }
    </script>

</body>
</html>